@using System.Net.Http.Headers
@using Roovia.Interfaces
@inject ICdnService CdnService
@inject IHttpClientFactory HttpClientFactory
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime

<div class="cdn-file-upload @(IsCompact ? "compact" : "")">
    <div class="file-upload-container @(_isDragging ? "dragging" : "") @(IsUploading ? "uploading" : "")">
        <InputFile OnChange="HandleFileSelected"
        class="file-input"
        accept="@AcceptedFileTypes"
        multiple="@Multiple"
        disabled="@IsUploading" />

        <div class="upload-prompt">
            @if (!IsUploading)
            {
                <div class="upload-icon">
                    <i class="fa-light fa-cloud-arrow-up fa-2x"></i>
                </div>
                <div class="upload-instructions">
                    <h4>@Title</h4>
                    <p>@Description</p>
                    <span class="file-hint">@FileTypeHint</span>
                    <div class="file-size-hint">
                        <small>Maximum file size: @FormatFileSize(MaxFileSize)</small>
                    </div>
                </div>
            }
            else
            {
                <div class="upload-progress">
                    <div class="progress">
                        <div class="progress-bar" role="progressbar" style="width: @(UploadProgress)%" aria-valuenow="@UploadProgress" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                    <div class="d-flex justify-content-between w-100">
                        <span>Uploading @_currentFileName... @UploadProgress%</span>
                        <span>@FormatFileSize(_bytesUploaded) of @FormatFileSize(_totalBytes)</span>
                    </div>
                    <div class="upload-speed mt-1">
                        <small>@_uploadSpeedText</small>
                    </div>
                    @if (EnableCancelUpload)
                    {
                        <button @onclick="CancelUpload" class="btn btn-sm btn-outline-danger mt-2">Cancel</button>
                    }
                </div>
            }
        </div>
    </div>

    @if (UploadedFiles.Any() && !HideFileList)
    {
        <div class="uploaded-files">
            <h5>Uploaded Files</h5>
            <div class="file-list">
                @foreach (var file in UploadedFiles)
                {
                    <div class="file-item">
                        <div class="file-icon">
                            @if (file.ContentType.StartsWith("image/"))
                            {
                                <i class="fa-light fa-image"></i>
                            }
                            else if (file.ContentType.Contains("pdf"))
                            {
                                <i class="fa-light fa-file-pdf"></i>
                            }
                            else if (file.ContentType.Contains("word"))
                            {
                                <i class="fa-light fa-file-word"></i>
                            }
                            else if (file.ContentType.Contains("excel") || file.ContentType.Contains("sheet"))
                            {
                                <i class="fa-light fa-file-excel"></i>
                            }
                            else if (file.ContentType.StartsWith("video/"))
                            {
                                <i class="fa-light fa-file-video"></i>
                            }
                            else if (file.ContentType.StartsWith("audio/"))
                            {
                                <i class="fa-light fa-file-audio"></i>
                            }
                            else
                            {
                                <i class="fa-light fa-file"></i>
                            }
                        </div>
                        <div class="file-details">
                            <div class="file-name">@file.FileName</div>
                            <div class="file-size">@FormatFileSize(file.Size)</div>
                        </div>
                        <div class="file-actions">
                            <button @onclick="() => ViewFile(file)" class="btn btn-sm btn-outline-primary" title="View file">
                                <i class="fa-light fa-eye"></i>
                            </button>
                            @if (AllowRename)
                            {
                                <button @onclick="() => RenameFile(file)" class="btn btn-sm btn-outline-secondary" title="Rename file">
                                    <i class="fa-light fa-edit"></i>
                                </button>
                            }
                            @if (AllowDelete)
                            {
                                <button @onclick="() => DeleteFile(file)" class="btn btn-sm btn-outline-danger" title="Delete file">
                                    <i class="fa-light fa-trash"></i>
                                </button>
                            }
                        </div>
                    </div>
                }
            </div>
        </div>
    }

    @if (_showRenameDialog)
    {
        <div class="modal fade show" style="display: block;" tabindex="-1">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Rename File</h5>
                        <button type="button" class="btn-close" @onclick="() => _showRenameDialog = false"></button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="newFileName">New file name:</label>
                            <input type="text" class="form-control" id="newFileName" @bind="_newFileName" />
                            <small class="form-text text-muted">Enter the new name without extension.</small>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" @onclick="() => _showRenameDialog = false">Cancel</button>
                        <button type="button" class="btn btn-primary" @onclick="PerformRename">Save</button>
                    </div>
                </div>
            </div>
            <div class="modal-backdrop fade show"></div>
        </div>
    }
</div>

@code {
    [Parameter] public string Title { get; set; } = "Upload Files";
    [Parameter] public string Description { get; set; } = "Drag and drop files here, or click to browse";
    [Parameter] public string FileTypeHint { get; set; } = "Accepted file types: JPG, PNG, PDF, DOC, XLSX";
    [Parameter] public string Category { get; set; } = "documents";
    [Parameter] public string AcceptedFileTypes { get; set; } = ".jpg,.jpeg,.png,.pdf,.doc,.docx,.xls,.xlsx,.csv,.txt,.mp4,.mp3,.zip";
    [Parameter] public bool Multiple { get; set; } = false;
    [Parameter] public long MaxFileSize { get; set; } = 209715200; // 200MB default
    [Parameter] public bool IsCompact { get; set; } = false;
    [Parameter] public bool HideFileList { get; set; } = false;
    [Parameter] public bool AllowDelete { get; set; } = true;
    [Parameter] public bool AllowRename { get; set; } = true;
    [Parameter] public bool EnableCancelUpload { get; set; } = true;
    [Parameter] public bool UseChunkedUpload { get; set; } = true; // Enable chunked upload for large files
    [Parameter] public int ChunkSize { get; set; } = 5 * 1024 * 1024; // 5MB chunks
    [Parameter] public EventCallback<UploadedFileInfo> OnFileUploaded { get; set; }
    [Parameter] public EventCallback<List<UploadedFileInfo>> OnFilesUploaded { get; set; }
    [Parameter] public EventCallback<UploadedFileInfo> OnFileDeleted { get; set; }
    [Parameter] public EventCallback<UploadedFileInfo> OnFileRenamed { get; set; }

    private bool _isDragging = false;
    private bool IsUploading { get; set; } = false;
    private int UploadProgress { get; set; } = 0;
    private List<UploadedFileInfo> UploadedFiles { get; set; } = new List<UploadedFileInfo>();
    private CancellationTokenSource _cancellationTokenSource;
    private string _currentFileName = "";
    private long _bytesUploaded = 0;
    private long _totalBytes = 0;
    private DateTime _uploadStartTime;
    private string _uploadSpeedText = "";
    private Timer _speedUpdateTimer;
    private bool _showRenameDialog = false;
    private string _newFileName = "";
    private UploadedFileInfo _selectedFile;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Make sure scripts are loaded
            await JSRuntime.InvokeVoidAsync("addDragDropListeners", DotNetObjectReference.Create(this));

            // Check if fileUpload.js is loaded
            try
            {
                await JSRuntime.InvokeVoidAsync("eval", "typeof openUrlWithApiKey === 'function'");
            }
            catch
            {
                // If not loaded, warn in console
                await JSRuntime.InvokeVoidAsync("console.warn", "fileUpload.js is not loaded. File viewing may not work correctly.");
            }
        }
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        try
        {
            IsUploading = true;
            UploadProgress = 0;
            _cancellationTokenSource = new CancellationTokenSource();

            var uploadedFiles = new List<UploadedFileInfo>();

            foreach (var file in e.GetMultipleFiles(Multiple ? 10 : 1))
            {
                if (file.Size > MaxFileSize)
                {
                    await JSRuntime.InvokeVoidAsync("alert", $"File {file.Name} exceeds the maximum file size of {FormatFileSize(MaxFileSize)}");
                    continue;
                }

                _currentFileName = file.Name;
                _totalBytes = file.Size;
                _bytesUploaded = 0;
                _uploadStartTime = DateTime.Now;

                // Start the timer to update upload speed
                _speedUpdateTimer = new Timer(UpdateUploadSpeed, null, 0, 1000);

                // Update progress as we upload
                UploadProgress = 0;
                StateHasChanged();

                UploadedFileInfo fileInfo;

                if (UseChunkedUpload && file.Size > ChunkSize)
                {
                    // Use chunked upload for large files
                    fileInfo = await UploadLargeFile(file, _cancellationTokenSource.Token);
                }
                else
                {
                    // Use standard upload for smaller files
                    fileInfo = await UploadStandardFile(file, _cancellationTokenSource.Token);
                }

                if (fileInfo != null)
                {
                    // Add to local list and trigger event
                    UploadedFiles.Add(fileInfo);
                    uploadedFiles.Add(fileInfo);
                    await OnFileUploaded.InvokeAsync(fileInfo);
                }

                // Stop the timer
                _speedUpdateTimer?.Dispose();
                _speedUpdateTimer = null;
            }

            // Notify if multiple files were uploaded
            if (uploadedFiles.Count > 0)
            {
                await OnFilesUploaded.InvokeAsync(uploadedFiles);
            }
        }
        catch (OperationCanceledException)
        {
            await JSRuntime.InvokeVoidAsync("console.log", "Upload was canceled by user");
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", "Error during upload", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", "An error occurred during upload. Please try again.");
        }
        finally
        {
            IsUploading = false;
            UploadProgress = 0;
            _speedUpdateTimer?.Dispose();
            _speedUpdateTimer = null;
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
            StateHasChanged();
        }
    }

    private async Task<UploadedFileInfo> UploadStandardFile(IBrowserFile file, CancellationToken cancellationToken)
    {
        // Create HTTP client
        var httpClient = HttpClientFactory.CreateClient();
        httpClient.Timeout = TimeSpan.FromHours(1); // Extended timeout for large files

        // Create multipart form content
        using var content = new MultipartFormDataContent();

        // Use a progress tracking stream
        var progressStream = new ProgressStream(
            file.OpenReadStream(MaxFileSize),
            async size =>
            {
                _bytesUploaded = size;
                UploadProgress = (int)(size * 100 / _totalBytes);
                await InvokeAsync(() => this.StateHasChanged());
            });

        var fileContent = new StreamContent(progressStream);
        fileContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType);

        content.Add(fileContent, "file", file.Name);
        content.Add(new StringContent(Category), "category");

        // Upload through API on the main application
        var apiUrl = new Uri(NavigationManager.BaseUri).GetLeftPart(UriPartial.Authority) + "/api/cdn/upload";
        var response = await httpClient.PostAsync(apiUrl, content, cancellationToken);

        if (response.IsSuccessStatusCode)
        {
            UploadProgress = 100;
            StateHasChanged();

            var responseContent = await response.Content.ReadFromJsonAsync<UploadResponse>(cancellationToken: cancellationToken);

            if (responseContent != null && responseContent.success)
            {
                return new UploadedFileInfo
                    {
                        FileName = file.Name,
                        Url = responseContent.url,     // This URL will be from the CDN domain
                        ContentType = file.ContentType,
                        Size = file.Size,
                        Category = Category
                    };
            }
        }
        else
        {
            var errorContent = await response.Content.ReadAsStringAsync(cancellationToken);
            await JSRuntime.InvokeVoidAsync("console.error", "Upload failed", errorContent);
            await JSRuntime.InvokeVoidAsync("alert", $"Failed to upload {file.Name}. Server returned an error.");
        }

        return null;
    }

    private async Task<UploadedFileInfo> UploadLargeFile(IBrowserFile file, CancellationToken cancellationToken)
    {
        // Only implement chunked upload if required, this is a placeholder for now
        // Would require server-side changes to support chunked uploading
        // For now, fall back to standard upload
        return await UploadStandardFile(file, cancellationToken);
    }

    private async void UpdateUploadSpeed(object state)
    {
        if (_bytesUploaded > 0 && _totalBytes > 0)
        {
            var elapsed = DateTime.Now - _uploadStartTime;
            if (elapsed.TotalSeconds > 0)
            {
                var bytesPerSecond = _bytesUploaded / elapsed.TotalSeconds;
                _uploadSpeedText = $"Upload speed: {FormatFileSize((long)bytesPerSecond)}/s";

                // Calculate estimated time remaining
                var bytesRemaining = _totalBytes - _bytesUploaded;
                if (bytesPerSecond > 0 && bytesRemaining > 0)
                {
                    var secondsRemaining = bytesRemaining / bytesPerSecond;
                    _uploadSpeedText += $" - Estimated time remaining: {FormatTimeRemaining(secondsRemaining)}";
                }

                await InvokeAsync(() => this.StateHasChanged());
            }
        }
    }

    private string FormatTimeRemaining(double seconds)
    {
        TimeSpan time = TimeSpan.FromSeconds(seconds);
        if (time.TotalHours >= 1)
        {
            return $"{time.Hours}h {time.Minutes}m {time.Seconds}s";
        }
        else if (time.TotalMinutes >= 1)
        {
            return $"{time.Minutes}m {time.Seconds}s";
        }
        else
        {
            return $"{time.Seconds}s";
        }
    }

    private void CancelUpload()
    {
        _cancellationTokenSource?.Cancel();
    }

    private async Task DeleteFile(UploadedFileInfo file)
    {
        try
        {
            // Create HTTP client and set API key
            var httpClient = HttpClientFactory.CreateClient();
            var apiKey = CdnService.GetApiKey();
            httpClient.DefaultRequestHeaders.Add("X-Api-Key", apiKey);

            // Use full API URL with the API key in headers
            var apiUrl = new Uri(NavigationManager.BaseUri).GetLeftPart(UriPartial.Authority) + "/api/cdn/delete?path=" + Uri.EscapeDataString(file.Url);
            var response = await httpClient.DeleteAsync(apiUrl);

            if (response.IsSuccessStatusCode)
            {
                var responseContent = await response.Content.ReadFromJsonAsync<DeleteResponse>();

                if (responseContent != null && responseContent.success)
                {
                    UploadedFiles.Remove(file);
                    await OnFileDeleted.InvokeAsync(file);
                    StateHasChanged();
                    await JSRuntime.InvokeVoidAsync("console.log", "File deleted successfully:", file.FileName);
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("console.error", "Delete failed with success=false", responseContent?.message);
                    await JSRuntime.InvokeVoidAsync("alert", $"Failed to delete file: {responseContent?.message}");
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                await JSRuntime.InvokeVoidAsync("console.error", "Delete failed", errorContent);
                await JSRuntime.InvokeVoidAsync("alert", "Failed to delete file. Server returned an error.");
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", "Error deleting file", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", "An error occurred while deleting the file. Please try again.");
        }
    }

    private void RenameFile(UploadedFileInfo file)
    {
        _selectedFile = file;
        _newFileName = Path.GetFileNameWithoutExtension(file.FileName);
        _showRenameDialog = true;
        StateHasChanged();
    }

    private async Task PerformRename()
    {
        if (_selectedFile == null || string.IsNullOrWhiteSpace(_newFileName))
        {
            await JSRuntime.InvokeVoidAsync("alert", "Please enter a valid file name.");
            return;
        }

        try
        {
            // Get API key
            var apiKey = CdnService.GetApiKey();

            // Call JS function to rename file
            var result = await JSRuntime.InvokeAsync<RenameResult>("renameFile", _selectedFile.Url, _newFileName, apiKey);

            if (result.success)
            {
                _showRenameDialog = false;

                // Update local file list
                var oldFile = _selectedFile;
                var index = UploadedFiles.IndexOf(oldFile);

                if (index >= 0)
                {
                    // Update with new URL and filename
                    var fileName = Path.GetFileName(result.url);
                    UploadedFiles[index].Url = result.url;
                    UploadedFiles[index].FileName = fileName;

                    // Notify parent component
                    await OnFileRenamed.InvokeAsync(UploadedFiles[index]);
                }

                StateHasChanged();
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("alert", $"Failed to rename file: {result.message}");
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", "Error renaming file", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", "An error occurred while renaming the file. Please try again.");
        }
    }

    private async Task ViewFile(UploadedFileInfo file)
    {
        try
        {
            // Get API key
            var apiKey = CdnService.GetApiKey();

            // Use JS function for viewing
            await JSRuntime.InvokeVoidAsync("openUrlWithApiKey", file.Url, apiKey);
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", "Error viewing file", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", "Failed to view file. Please try again.");
        }
    }

    [JSInvokable]
    public void OnDragEnter()
    {
        _isDragging = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnDragLeave()
    {
        _isDragging = false;
        StateHasChanged();
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;

        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }

        return $"{len:0.##} {sizes[order]}";
    }

    // Stream wrapper to track upload progress
    private class ProgressStream : Stream
    {
        private readonly Stream _baseStream;
        private readonly Action<long> _progressCallback;
        private long _totalBytesRead;

        public ProgressStream(Stream baseStream, Action<long> progressCallback)
        {
            _baseStream = baseStream;
            _progressCallback = progressCallback;
            _totalBytesRead = 0;
        }

        public override bool CanRead => _baseStream.CanRead;
        public override bool CanSeek => _baseStream.CanSeek;
        public override bool CanWrite => _baseStream.CanWrite;
        public override long Length => _baseStream.Length;
        public override long Position
        {
            get => _baseStream.Position;
            set => _baseStream.Position = value;
        }

        public override void Flush() => _baseStream.Flush();

        public override int Read(byte[] buffer, int offset, int count)
        {
            int bytesRead = _baseStream.Read(buffer, offset, count);
            _totalBytesRead += bytesRead;
            _progressCallback(_totalBytesRead);
            return bytesRead;
        }

        public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            int bytesRead = await _baseStream.ReadAsync(buffer, offset, count, cancellationToken);
            _totalBytesRead += bytesRead;
            _progressCallback(_totalBytesRead);
            return bytesRead;
        }

        public override long Seek(long offset, SeekOrigin origin) => _baseStream.Seek(offset, origin);
        public override void SetLength(long value) => _baseStream.SetLength(value);
        public override void Write(byte[] buffer, int offset, int count) => _baseStream.Write(buffer, offset, count);

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                _baseStream.Dispose();
            }
            base.Dispose(disposing);
        }
    }

    public class UploadedFileInfo
    {
        public string FileName { get; set; }
        public string Url { get; set; }
        public string ContentType { get; set; }
        public long Size { get; set; }
        public string Category { get; set; }
    }

    private class UploadResponse
    {
        public bool success { get; set; }
        public string url { get; set; }
        public string fileName { get; set; }
        public string contentType { get; set; }
        public long size { get; set; }
        public string category { get; set; }
    }

    private class DeleteResponse
    {
        public bool success { get; set; }
        public string message { get; set; }
    }

    private class RenameResult
    {
        public bool success { get; set; }
        public string url { get; set; }
        public string message { get; set; }
    }
}
<style>
    /* cdn-file-upload.css */
    .cdn-file-upload {
        margin-bottom: 1.5rem;
    }

    .file-upload-container {
        position: relative;
        border: 2px dashed #ccc;
        border-radius: 6px;
        padding: 2rem;
        text-align: center;
        background-color: #f9f9f9;
        transition: all 0.2s ease;
    }

        .file-upload-container.dragging {
            background-color: #e9f7fe;
            border-color: #0d6efd;
        }

        .file-upload-container.uploading {
            background-color: #f8f9fa;
            border-color: #6c757d;
        }

    .file-input {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        cursor: pointer;
        z-index: 10;
    }

    .upload-prompt {
        display: flex;
        flex-direction: column;
        align-items: center;
        pointer-events: none;
    }

    .upload-instructions h4 {
        margin-bottom: 0.5rem;
        font-size: 1.25rem;
    }

    .upload-instructions p {
        margin-bottom: 0.5rem;
        color: #6c757d;
    }

    .file-hint {
        font-size: 0.875rem;
        color: #6c757d;
    }

    .file-size-hint {
        font-size: 0.75rem;
        color: #6c757d;
        margin-top: 0.25rem;
    }

    .upload-progress {
        width: 100%;
        max-width: 400px;
    }

    .progress {
        height: 0.75rem;
        margin-bottom: 0.5rem;
    }

    .upload-speed {
        font-size: 0.75rem;
        color: #6c757d;
    }

    .compact .file-upload-container {
        padding: 1rem;
    }

    .compact .upload-instructions h4 {
        font-size: 1rem;
    }

    .uploaded-files {
        margin-top: 1.5rem;
    }

    .file-list {
        border: 1px solid #e9ecef;
        border-radius: 6px;
        overflow: hidden;
    }

    .file-item {
        display: flex;
        align-items: center;
        padding: 0.75rem 1rem;
        border-bottom: 1px solid #e9ecef;
    }

        .file-item:last-child {
            border-bottom: none;
        }

    .file-icon {
        font-size: 1.5rem;
        margin-right: 1rem;
        color: #6c757d;
        width: 32px;
        text-align: center;
    }

    .file-details {
        flex: 1;
    }

    .file-name {
        font-weight: 500;
        margin-bottom: 0.25rem;
        word-break: break-all;
    }

    .file-size {
        font-size: 0.875rem;
        color: #6c757d;
    }

    .file-actions {
        display: flex;
        gap: 0.5rem;
    }
</style>