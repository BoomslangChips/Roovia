@using System.Net.Http.Headers
@using Roovia.Interfaces
@inject ICdnService CdnService
@inject IHttpClientFactory HttpClientFactory
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime

<div class="cdn-file-upload @(IsCompact ? "compact" : "")">
    <div class="file-upload-container @(_isDragging ? "dragging" : "") @(IsUploading ? "uploading" : "")">
        <InputFile OnChange="HandleFileSelected"
                   class="file-input"
                   accept="@AcceptedFileTypes"
                   multiple="@Multiple"
                   disabled="@IsUploading" />

        <div class="upload-prompt">
            @if (!IsUploading)
            {
                        <div class="upload-icon">
                            <i class="fa-light fa-cloud-arrow-up fa-2x"></i>
                        </div>
                        <div class="upload-instructions">
                            <h4>@Title</h4>
                            <p>@Description</p>
                            <span class="file-hint">@FileTypeHint</span>
                            <div class="file-size-hint">
                                <small>Maximum file size: @FormatFileSize(MaxFileSize)</small>
                            </div>
                        </div>
            }
            else
            {
                        <div class="upload-progress">
                            <div class="progress">
                                <div class="progress-bar" role="progressbar" style="width: @(UploadProgress)%" aria-valuenow="@UploadProgress" aria-valuemin="0" aria-valuemax="100"></div>
                            </div>
                            <div class="d-flex justify-content-between w-100">
                                <span>Uploading @_currentFileName... @UploadProgress%</span>
                                <span>@FormatFileSize(_bytesUploaded) of @FormatFileSize(_totalBytes)</span>
                            </div>
                            <div class="upload-speed mt-1">
                                <small>@_uploadSpeedText</small>
                            </div>
                    @if (EnableCancelUpload)
                    {
                                        <button @onclick="CancelUpload" class="btn btn-sm btn-outline-danger mt-2">
                                            <i class="fa-light fa-times me-2"></i>Cancel
                                        </button>
                    }
                        </div>
            }
        </div>
    </div>

    @if (UploadedFiles.Any() && !HideFileList)
    {
                <div class="uploaded-files">
                    <h5>Uploaded Files</h5>
                    <div class="file-list">
                @foreach (var file in UploadedFiles)
                {
                                    <div class="file-item">
                                        <div class="file-icon">
                            @if (file.ContentType.StartsWith("image/"))
                            {
                                                        <i class="fa-light fa-image"></i>
                            }
                            else if (file.ContentType.Contains("pdf"))
                            {
                                                        <i class="fa-light fa-file-pdf"></i>
                            }
                            else if (file.ContentType.Contains("word"))
                            {
                                                        <i class="fa-light fa-file-word"></i>
                            }
                            else if (file.ContentType.Contains("excel") || file.ContentType.Contains("sheet"))
                            {
                                                        <i class="fa-light fa-file-excel"></i>
                            }
                            else if (file.ContentType.StartsWith("video/"))
                            {
                                                        <i class="fa-light fa-file-video"></i>
                            }
                            else if (file.ContentType.StartsWith("audio/"))
                            {
                                                        <i class="fa-light fa-file-audio"></i>
                            }
                            else
                            {
                                                        <i class="fa-light fa-file"></i>
                            }
                                        </div>
                                        <div class="file-details">
                                            <div class="file-name">@file.FileName</div>
                                            <div class="file-size">@FormatFileSize(file.Size)</div>
                                        </div>
                                        <div class="file-actions">
                                            <button @onclick="() => ViewFile(file)" class="btn btn-sm btn-outline-primary" title="View file">
                                                <i class="fa-light fa-eye"></i>
                                            </button>
                            @if (AllowRename)
                            {
                                                        <button @onclick="() => RenameFile(file)" class="btn btn-sm btn-outline-secondary" title="Rename file">
                                                            <i class="fa-light fa-edit"></i>
                                                        </button>
                            }
                            @if (AllowDelete)
                            {
                                                        <button @onclick="() => DeleteFile(file)" class="btn btn-sm btn-outline-danger" title="Delete file">
                                                            <i class="fa-light fa-trash"></i>
                                                        </button>
                            }
                                        </div>
                                    </div>
                }
                    </div>
                </div>
    }

    @if (_showRenameDialog)
    {
                <div class="modal fade show" style="display: block;" tabindex="-1">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">Rename File</h5>
                                <button type="button" class="btn-close" @onclick="() => _showRenameDialog = false"></button>
                            </div>
                            <div class="modal-body">
                                <div class="form-group">
                                    <label for="newFileName">New file name:</label>
                                    <input type="text" class="form-control" id="newFileName" @bind="_newFileName" />
                                    <small class="form-text text-muted">Enter the new name without extension.</small>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" @onclick="() => _showRenameDialog = false">Cancel</button>
                                <button type="button" class="btn btn-primary" @onclick="PerformRename">Save</button>
                            </div>
                        </div>
                    </div>
                    <div class="modal-backdrop fade show"></div>
                </div>
    }
</div>

@code {
    [Parameter] public string Title { get; set; } = "Upload Files";
    [Parameter] public string Description { get; set; } = "Drag and drop files here, or click to browse";
    [Parameter] public string FileTypeHint { get; set; } = "Accepted file types: JPG, PNG, PDF, DOC, XLSX";
    [Parameter] public string Category { get; set; } = "documents";
    [Parameter] public string FolderPath { get; set; } = ""; // Added to support specific folder paths
    [Parameter] public string AcceptedFileTypes { get; set; } = ".jpg,.jpeg,.png,.pdf,.doc,.docx,.xls,.xlsx,.csv,.txt,.mp4,.mp3,.zip";
    [Parameter] public bool Multiple { get; set; } = false;
    [Parameter] public long MaxFileSize { get; set; } = 209715200; // 200MB default
    [Parameter] public bool IsCompact { get; set; } = false;
    [Parameter] public bool HideFileList { get; set; } = false;
    [Parameter] public bool AllowDelete { get; set; } = true;
    [Parameter] public bool AllowRename { get; set; } = true;
    [Parameter] public bool EnableCancelUpload { get; set; } = true;
    [Parameter] public bool UseChunkedUpload { get; set; } = true; // Enable chunked upload for large files
    [Parameter] public int ChunkSize { get; set; } = 5 * 1024 * 1024; // 5MB chunks
    [Parameter] public EventCallback<UploadedFileInfo> OnFileUploaded { get; set; }
    [Parameter] public EventCallback<List<UploadedFileInfo>> OnFilesUploaded { get; set; }
    [Parameter] public EventCallback<UploadedFileInfo> OnFileDeleted { get; set; }
    [Parameter] public EventCallback<UploadedFileInfo> OnFileRenamed { get; set; }

    private bool _isDragging = false;
    private bool IsUploading { get; set; } = false;
    private int UploadProgress { get; set; } = 0;
    private List<UploadedFileInfo> UploadedFiles { get; set; } = new List<UploadedFileInfo>();
    private CancellationTokenSource _cancellationTokenSource;
    private string _currentFileName = "";
    private long _bytesUploaded = 0;
    private long _totalBytes = 0;
    private DateTime _uploadStartTime;
    private string _uploadSpeedText = "";
    private Timer _speedUpdateTimer;
    private bool _showRenameDialog = false;
    private string _newFileName = "";
    private UploadedFileInfo _selectedFile;
    private string _apiKey;

    // Production API URL - always use this for test environments
    private readonly string _productionApiUrl = "https://portal.roovia.co.za";

    protected override async Task OnInitializedAsync()
    {
        // Initialize API key at component load
        _apiKey = CdnService.GetApiKey();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Make sure API key is set in JavaScript
            await JSRuntime.InvokeVoidAsync("setCdnApiKey", _apiKey);

            // Register for drag/drop events with the .NET reference
            await JSRuntime.InvokeVoidAsync("addDragDropListeners", DotNetObjectReference.Create(this));
        }
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        try
        {
            IsUploading = true;
            UploadProgress = 0;
            _cancellationTokenSource = new CancellationTokenSource();

            var uploadedFiles = new List<UploadedFileInfo>();

            var files = Multiple ? e.GetMultipleFiles(10) : new[] { e.File };

            foreach (var file in files)
            {
                if (file.Size > MaxFileSize)
                {
                    await JSRuntime.InvokeVoidAsync("alert", $"File {file.Name} exceeds the maximum file size of {FormatFileSize(MaxFileSize)}");
                    continue;
                }

                _currentFileName = file.Name;
                _totalBytes = file.Size;
                _bytesUploaded = 0;
                _uploadStartTime = DateTime.Now;

                // Start the timer to update upload speed
                _speedUpdateTimer = new Timer(UpdateUploadSpeed, null, 0, 1000);

                // Update progress as we upload
                UploadProgress = 0;
                StateHasChanged();

                UploadedFileInfo fileInfo;

                if (UseChunkedUpload && file.Size > ChunkSize)
                {
                    // Use chunked upload for large files
                    fileInfo = await UploadLargeFile(file, _cancellationTokenSource.Token);
                }
                else
                {
                    // Use standard upload for smaller files
                    fileInfo = await UploadStandardFile(file, _cancellationTokenSource.Token);
                }

                if (fileInfo != null)
                {
                    // Add to local list and trigger event
                    UploadedFiles.Add(fileInfo);
                    uploadedFiles.Add(fileInfo);
                    await OnFileUploaded.InvokeAsync(fileInfo);
                }

                // Stop the timer
                _speedUpdateTimer?.Dispose();
                _speedUpdateTimer = null;
            }

            // Notify if multiple files were uploaded
            if (uploadedFiles.Count > 0)
            {
                await OnFilesUploaded.InvokeAsync(uploadedFiles);
            }
        }
        catch (OperationCanceledException)
        {
            await JSRuntime.InvokeVoidAsync("console.log", "Upload was canceled by user");
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", "Error during upload", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", "An error occurred during upload. Please try again.");
        }
        finally
        {
            IsUploading = false;
            UploadProgress = 0;
            _speedUpdateTimer?.Dispose();
            _speedUpdateTimer = null;
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
            StateHasChanged();
        }
    }

    private async Task<UploadedFileInfo> UploadStandardFile(IBrowserFile file, CancellationToken cancellationToken)
    {
        try
        {
            // Use the CdnService for direct upload when available
            if (CdnService.IsDirectAccessAvailable() && !CdnService.IsDevEnvironment())
            {
                var stream = file.OpenReadStream(MaxFileSize);
                var progressStream2 = new ProgressStream(stream, async size =>
                {
                    _bytesUploaded = size;
                    UploadProgress = (int)(size * 100 / _totalBytes);
                    await InvokeAsync(() => StateHasChanged());
                });

                var url = await CdnService.UploadFileAsync(
                    progressStream2,
                    file.Name,
                    file.ContentType,
                    Category,
                    FolderPath);

                UploadProgress = 100;
                await InvokeAsync(() => StateHasChanged());

                return new UploadedFileInfo
                    {
                        FileName = file.Name,
                        Url = url,
                        ContentType = file.ContentType,
                        Size = file.Size,
                        Category = Category
                    };
            }

            // Otherwise use HTTP client
            var httpClient = HttpClientFactory.CreateClient();
            httpClient.Timeout = TimeSpan.FromHours(1); // Extended timeout for large files

            // Ensure we have the API key header
            if (!httpClient.DefaultRequestHeaders.Contains("X-Api-Key"))
            {
                httpClient.DefaultRequestHeaders.Add("X-Api-Key", _apiKey);
            }

            // Create multipart form content
            using var content = new MultipartFormDataContent();

            // Use a progress tracking stream
            var progressStream = new ProgressStream(
                file.OpenReadStream(MaxFileSize),
                async size =>
                {
                    _bytesUploaded = size;
                    UploadProgress = (int)(size * 100 / _totalBytes);
                    await InvokeAsync(() => this.StateHasChanged());
                });

            var fileContent = new StreamContent(progressStream);
            fileContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType);

            content.Add(fileContent, "file", file.Name);
            content.Add(new StringContent(Category), "category");

            // Add folder path if provided
            if (!string.IsNullOrEmpty(FolderPath))
            {
                content.Add(new StringContent(FolderPath), "folder");
            }

            // FIXED: Always use production API endpoints
            var endpoints = new string[] {
                // Primary production endpoints
                $"{_productionApiUrl}/api/cdn/upload",
                // Fallback to local endpoints for development only
                $"{NavigationManager.BaseUri.TrimEnd('/')}/api/cdn/upload",
                $"{NavigationManager.BaseUri.TrimEnd('/')}/api/cdncompat/upload"
        };

            // Log upload attempt for debugging
            await JSRuntime.InvokeVoidAsync("console.log", $"Attempting to upload file {file.Name} to {endpoints[0]}");

            foreach (var apiUrl in endpoints)
            {
                try
                {
                    await JSRuntime.InvokeVoidAsync("console.log", $"Trying endpoint: {apiUrl}");
                    var response = await httpClient.PostAsync(apiUrl, content, cancellationToken);

                    if (response.IsSuccessStatusCode)
                    {
                        UploadProgress = 100;
                        StateHasChanged();

                        var responseContent = await response.Content.ReadFromJsonAsync<UploadResponse>(cancellationToken: cancellationToken);

                        if (responseContent != null && responseContent.success)
                        {
                            await JSRuntime.InvokeVoidAsync("console.log", $"Upload successful using endpoint: {apiUrl}");
                            return new UploadedFileInfo
                                {
                                    FileName = file.Name,
                                    Url = responseContent.url,
                                    ContentType = file.ContentType,
                                    Size = file.Size,
                                    Category = Category
                                };
                        }
                    }
                    else
                    {
                        var errorContent = await response.Content.ReadAsStringAsync();
                        await JSRuntime.InvokeVoidAsync("console.error", $"Upload failed with status {response.StatusCode}: {errorContent}");
                    }
                }
                catch (Exception ex)
                {
                    // Log the error but continue to the next endpoint
                    await JSRuntime.InvokeVoidAsync("console.error", $"Error with endpoint {apiUrl}: {ex.Message}");
                    continue;
                }
            }

            // If we reach here, all endpoints failed
            await JSRuntime.InvokeVoidAsync("console.error", "Upload failed on all endpoints");
            await JSRuntime.InvokeVoidAsync("alert", $"Failed to upload {file.Name}. Server returned an error.");
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", "Upload exception", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", $"Error uploading {file.Name}: {ex.Message}");
        }

        return null;
    }

    private async Task<UploadedFileInfo> UploadLargeFile(IBrowserFile file, CancellationToken cancellationToken)
    {
        // For now, use the same approach as standard upload
        // In the future, implement chunked uploading with better progress tracking
        return await UploadStandardFile(file, cancellationToken);
    }

    private async void UpdateUploadSpeed(object state)
    {
        if (_bytesUploaded > 0 && _totalBytes > 0)
        {
            var elapsed = DateTime.Now - _uploadStartTime;
            if (elapsed.TotalSeconds > 0)
            {
                var bytesPerSecond = _bytesUploaded / elapsed.TotalSeconds;
                _uploadSpeedText = $"Upload speed: {FormatFileSize((long)bytesPerSecond)}/s";

                // Calculate estimated time remaining
                var bytesRemaining = _totalBytes - _bytesUploaded;
                if (bytesPerSecond > 0 && bytesRemaining > 0)
                {
                    var secondsRemaining = bytesRemaining / bytesPerSecond;
                    _uploadSpeedText += $" - Estimated time remaining: {FormatTimeRemaining(secondsRemaining)}";
                }

                await InvokeAsync(() => this.StateHasChanged());
            }
        }
    }

    private string FormatTimeRemaining(double seconds)
    {
        TimeSpan time = TimeSpan.FromSeconds(seconds);
        if (time.TotalHours >= 1)
        {
            return $"{time.Hours}h {time.Minutes}m {time.Seconds}s";
        }
        else if (time.TotalMinutes >= 1)
        {
            return $"{time.Minutes}m {time.Seconds}s";
        }
        else
        {
            return $"{time.Seconds}s";
        }
    }

    private void CancelUpload()
    {
        _cancellationTokenSource?.Cancel();
    }

    private async Task DeleteFile(UploadedFileInfo file)
    {
        try
        {
            // Confirm the deletion with the user
            var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", $"Are you sure you want to delete {file.FileName}?");
            if (!confirmed)
                return;

            // Try to use CdnService directly
            if (await CdnService.DeleteFileAsync(file.Url))
            {
                UploadedFiles.Remove(file);
                await OnFileDeleted.InvokeAsync(file);
                StateHasChanged();
                return;
            }

            // Create HTTP client and set API key
            var httpClient = HttpClientFactory.CreateClient();
            if (!httpClient.DefaultRequestHeaders.Contains("X-Api-Key"))
            {
                httpClient.DefaultRequestHeaders.Add("X-Api-Key", _apiKey);
            }

            // FIXED: Always use production API endpoints first
            var endpoints = new string[] {
                // Primary production endpoint
                $"{_productionApiUrl}/api/cdn/delete?path={Uri.EscapeDataString(file.Url)}",
                // Fallback to local endpoints for development only
                $"{NavigationManager.BaseUri.TrimEnd('/')}/api/cdn/delete?path={Uri.EscapeDataString(file.Url)}",
                $"{NavigationManager.BaseUri.TrimEnd('/')}/api/cdncompat/delete?path={Uri.EscapeDataString(file.Url)}"
        };

            foreach (var apiUrl in endpoints)
            {
                try
                {
                    await JSRuntime.InvokeVoidAsync("console.log", $"Trying delete endpoint: {apiUrl}");
                    var response = await httpClient.DeleteAsync(apiUrl);

                    if (response.IsSuccessStatusCode)
                    {
                        var responseContent = await response.Content.ReadFromJsonAsync<DeleteResponse>();

                        if (responseContent != null && responseContent.success)
                        {
                            UploadedFiles.Remove(file);
                            await OnFileDeleted.InvokeAsync(file);
                            StateHasChanged();
                            await JSRuntime.InvokeVoidAsync("console.log", $"Delete successful using endpoint: {apiUrl}");
                            return;
                        }
                    }
                    else
                    {
                        var errorContent = await response.Content.ReadAsStringAsync();
                        await JSRuntime.InvokeVoidAsync("console.error", $"Delete failed with status {response.StatusCode}: {errorContent}");
                    }
                }
                catch (Exception ex)
                {
                    // Log the error but continue to the next endpoint
                    await JSRuntime.InvokeVoidAsync("console.error", $"Error with delete endpoint {apiUrl}: {ex.Message}");
                    continue;
                }
            }

            // If we get here, all endpoints failed
            await JSRuntime.InvokeVoidAsync("console.error", "Delete failed on all endpoints");
            await JSRuntime.InvokeVoidAsync("alert", "Failed to delete file. All server endpoints returned errors.");
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", "Error deleting file", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", "An error occurred while deleting the file. Please try again.");
        }
    }

    private void RenameFile(UploadedFileInfo file)
    {
        _selectedFile = file;
        _newFileName = Path.GetFileNameWithoutExtension(file.FileName);
        _showRenameDialog = true;
        StateHasChanged();
    }

    private async Task PerformRename()
    {
        if (_selectedFile == null || string.IsNullOrWhiteSpace(_newFileName))
        {
            await JSRuntime.InvokeVoidAsync("alert", "Please enter a valid file name.");
            return;
        }

        try
        {
            // Use external JS function to handle renames with fallbacks
            var result = await JSRuntime.InvokeAsync<RenameResult>("renameFile", _selectedFile.Url, _newFileName, _apiKey);

            if (result != null && result.success)
            {
                _showRenameDialog = false;

                // Update local file list
                var oldFile = _selectedFile;
                var index = UploadedFiles.IndexOf(oldFile);

                if (index >= 0)
                {
                    // Update with new URL and filename
                    var fileName = Path.GetFileName(result.url);
                    UploadedFiles[index].Url = result.url;
                    UploadedFiles[index].FileName = fileName;

                    // Notify parent component
                    await OnFileRenamed.InvokeAsync(UploadedFiles[index]);
                }

                await JSRuntime.InvokeVoidAsync("alert", "File renamed successfully");
                StateHasChanged();
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("alert", $"Failed to rename file: {result?.message ?? "Unknown error"}");
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", "Error renaming file", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", "An error occurred while renaming the file. Please try again.");
        }
    }

    private async Task ViewFile(UploadedFileInfo file)
    {
        try
        {
            // Use JS function for viewing
            await JSRuntime.InvokeVoidAsync("openUrlWithApiKey", file.Url, _apiKey);
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", "Error viewing file", ex.Message);
            await JSRuntime.InvokeVoidAsync("alert", "Failed to view file. Please try again.");
        }
    }

    [JSInvokable]
    public void OnDragEnter()
    {
        _isDragging = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnDragLeave()
    {
        _isDragging = false;
        StateHasChanged();
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;

        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }

        return $"{len:0.##} {sizes[order]}";
    }

    // Stream wrapper to track upload progress
    private class ProgressStream : Stream
    {
        private readonly Stream _baseStream;
        private readonly Action<long> _progressCallback;
        private long _totalBytesRead;

        public ProgressStream(Stream baseStream, Action<long> progressCallback)
        {
            _baseStream = baseStream;
            _progressCallback = progressCallback;
            _totalBytesRead = 0;
        }

        public override bool CanRead => _baseStream.CanRead;
        public override bool CanSeek => _baseStream.CanSeek;
        public override bool CanWrite => _baseStream.CanWrite;
        public override long Length => _baseStream.Length;
        public override long Position
        {
            get => _baseStream.Position;
            set => _baseStream.Position = value;
        }

        public override void Flush() => _baseStream.Flush();

        public override int Read(byte[] buffer, int offset, int count)
        {
            int bytesRead = _baseStream.Read(buffer, offset, count);
            _totalBytesRead += bytesRead;
            _progressCallback(_totalBytesRead);
            return bytesRead;
        }

        public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            int bytesRead = await _baseStream.ReadAsync(buffer, offset, count, cancellationToken);
            _totalBytesRead += bytesRead;
            _progressCallback(_totalBytesRead);
            return bytesRead;
        }

        public override long Seek(long offset, SeekOrigin origin) => _baseStream.Seek(offset, origin);
        public override void SetLength(long value) => _baseStream.SetLength(value);
        public override void Write(byte[] buffer, int offset, int count) => _baseStream.Write(buffer, offset, count);

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                _baseStream.Dispose();
            }
            base.Dispose(disposing);
        }
    }

    public class UploadedFileInfo
    {
        public string FileName { get; set; }
        public string Url { get; set; }
        public string ContentType { get; set; }
        public long Size { get; set; }
        public string Category { get; set; }
    }

    private class UploadResponse
    {
        public bool success { get; set; }
        public string url { get; set; }
        public string fileName { get; set; }
        public string contentType { get; set; }
        public long size { get; set; }
        public string category { get; set; }
        public string message { get; set; }
    }

    private class DeleteResponse
    {
        public bool success { get; set; }
        public string message { get; set; }
    }

    private class RenameResult
    {
        public bool success { get; set; }
        public string url { get; set; }
        public string message { get; set; }
    }
}